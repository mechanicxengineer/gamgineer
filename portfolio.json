{
  "user": {
    "logo": "gamegineer",
    "name": "Manish",
    "title": "Game Developer | Engineer",
    "location": "India",
    "slogan": "From movement to meaning, I engineer experiences that feel cinematic and alive. Gameplay is my language, code is my craft.",
    "bio": "Hi, I’m a Game developer & Engineer crafting immersive worlds with Unity and Unreal. I blend code, design, and systems to turn ideas into playable experiences."
  },
  "skills": [
    { "name": "Unreal Engine", "level": "85%" },
    { "name": "Unity", "level": "80%" },
    { "name": "C++", "level": "80%" },
    { "name": "C#", "level": "75%" },
    { "name": "AI Programming", "level": "60%" },
    { "name": "Physics Programming", "level": "75%" },
    { "name": "Shader Graph", "level": "50%" },
    { "name": "Blender", "level": "70%" }
  ],
  "projects": {
    "completed-games": [
      {
        "id": "completed-game-1",
        "title": "The Last Emberlight (In progress)",
        "description": ["The Last Emberlight is a 2D top-down adventure game inspired by classics like The Legend of Zelda. Built in Unity, it combines tile-based world design, sprite-driven visuals, and modular gameplay systems to create an immersive, scalable experience. The project emphasizes smart AI, dynamic interaction, and expressive UI feedback-perfect for expanding into a full-fledged narrative-driven title.",
        "Core Systems & Features:",
        "Tilemap & Sprite Architecture: World built using Unity’s tile palette system for seamless terrain, dungeons, and interiors. Characters and objects use hand-crafted sprites with layered animations.",
        "Character Movement System: Supports four-directional movement (up, down, left, right) with smooth transitions, collision handling, and contextual animations.",
        "Interaction & Pickup System: Players can interact with NPCs, open chests, collect items, and trigger events. Includes prompt-based UI and inventory integration.",
        "Smart Enemy AI: Enemies use behavior trees for patrolling, chasing, and attacking. Includes line-of-sight detection, obstacle avoidance, and difficulty scaling.",
        "Combat System: Real-time melee and ranged combat with hit detection, knockback, and cooldown logic. Includes weapon switching and attack animations.",
        "Damage & Health System: Modular damage handling with health bars, invincibility frames, and death states. Supports both player and enemy entities.",
        "Player Navigation System: Includes minimap tracking, location markers, and contextual hints to guide exploration and quest progression.",
        "Smart NPC AI: Dialogue-driven NPCs with schedules, reactions, and branching interactions. Includes quest triggers and dynamic world responses.",
        "Inventory System: Grid-based inventory with item stacking, equipment slots, and drag-and-drop functionality. Supports consumables, gear, and quest items.",
        "UI System: Displays health, coins, minimap, equipped items, and interaction prompts. Designed for clarity and minimalism with animated transitions.",
        "Save/load architecture and player progression tracking. (in progress)",
        "Quest system with branching narratives and dynamic outcomes. (in progress)",
        "Environmental puzzles and dungeon mechanics. (in progress)",
        "Visual polish for UI and combat feedback. (in progress)"],
        "video": "https://drive.google.com/file/d/1MvLqsdSJEx3YghdRTIstAIVdXrDd51H3/preview",
        "thumbnail": "images/the_last_emberlight.png",
        "tech": ["Unity", "2D", "Adventure", "Exploration", "Combat"],
        "repo": "https://github.com/mechanicxengineer/2D-Open-World",
        "live": ""
      },
      {
        "id": "completed-game-2",
        "title": "Monster Hunt",
        "description": ["Monster Hunt is a third-person shooter prototype designed to showcase a complete, immersive gameplay loop. Built with modular architecture and expressive feedback systems, it integrates advanced animation, responsive combat mechanics, and intelligent enemy behavior-ideal for cinematic action experiences and scalable game development.",
        "Core Systems & Features:",
        "Third-Person Movement Controller: Smooth camera-relative locomotion with sprinting, crouching, vaulting, and jump states. Includes root motion and physics-based transitions.",
        "FABRIK-Based Advanced Animation: Real-time inverse kinematics for precise hand and weapon alignment, dynamic aiming, and contextual interactions like climbing and ledge grabbing.",
        "Health & Damage Architecture: Modular health system with customizable damage types, resistances, and death triggers. Supports both player and AI entities with clean event-driven logic.",
        "Floating Damage Numbers: Stylized feedback system for hit confirmation. Includes critical hit indicators, scaling animations, and color-coded damage types.",
        "Weapon Inventory & Switching: Slot-based inventory with support for primary, secondary, and throwable weapons. Includes equip animations and seamless switching logic.",
        "Firing & Reloading Mechanics: Supports semi-auto, burst, and full-auto fire modes, reload interruptions, and synced ammo updates. Includes dry fire and reload feedback.",
        "Ammo & Gun UI Indicators: HUD elements for current weapon, ammo count, reload status, and weapon type. Designed for clarity and minimal screen clutter.",
        "Ammo Collection System: World pickups with contextual prompts, stacking logic, and auto-collect zones. Includes visual and audio feedback.",
        "Visual Effects Suite: Muzzle flashes, impact sparks, reload particles, and ambient FX. Designed for performance and style using modular VFX components.",
        "Smart AI Enemies: Behavior-driven AI with patrol, chase, and combat states. Includes line-of-sight detection, cover-seeking, flanking logic, and dynamic reaction to player actions. Supports difficulty scaling and modular behavior trees."],
        "video": "https://drive.google.com/file/d/1tRuiKT877iWEBaatgQi1HAaNpXsdToZ2/preview",
        "thumbnail": "images/monster_hunt.png",
        "tech": ["Unreal Engine", "C++", "Blueprints", "AI"],
        "repo": "https://github.com/mechanicxengineer/Monster-hunt",
        "live": ""
      },
      {
        "id": "completed-game-3",
        "title": "MinerCore Tycoon",
        "description": ["MinerCore Tycoon is a 2D idle mining simulator built in Unity, designed to demonstrate scalable systems for automation, resource flow, and visual feedback. The game blends sprite-based visuals with skeletal animation and modular gameplay loops, making it ideal for mobile or desktop platforms.",
        "Core Systems & Features:",
        "Sprite-Based Visuals & 2D Skeletal Animation: Combines hand-crafted sprites with Unity’s skeletal rigging for smooth, expressive character animations-ideal for workers, managers, and machinery.",
        "AI Workers & Managers: Autonomous agents with task assignment logic. Workers mine resources, while managers boost efficiency, automate upgrades, and reduce cooldowns.",
        "Work Timer System: Each mining task is governed by a timer loop. Includes visual countdowns, progress bars, and manager-based acceleration logic.",
        "Upgrade System: Tiered upgrades for mining speed, worker efficiency, storage capacity, and automation. Includes UI feedback and cost scaling.",
        "Storage & Capacity System: Dynamic resource storage with overflow logic. Players must upgrade capacity to avoid bottlenecks and maximize idle gains.",
        "Currency System with Smart Formatting: Implements a scalable currency system with automatic formatting (e.g., 1,000 → 1K, 1,000,000 → 1M) for clean UI and intuitive progression."],
        "video": "https://drive.google.com/file/d/1cOKSjyD3cKSFQ5yKamrBpq-A4rA0NtcI/preview",
        "thumbnail": "images/minercore_tycoon.png",
        "tech": ["Unity", "Idle Simulation", "Resource Management", "2D"],
        "repo": "https://github.com/mechanicxengineer/Idle-Miner-Game",
        "live": ""
      },
      {
        "id": "completed-game-4",
        "title": "Fruity Match",
        "description": ["Fruity Match 3x3 is a vibrant 2D puzzle game built in Unity, featuring a classic match-3 mechanic with a juicy twist. Designed with polished visuals and responsive UI, the game challenges players to match colorful fruit tiles within a limited number of moves and a ticking timer-perfect for quick, satisfying gameplay sessions.",
        "Core Systems & Features:",
        "Sprite-Based Visuals: Hand-crafted fruit sprites with smooth animations and playful effects for matches, combos, and tile swaps.",
        "3x3 Match Grid: Compact grid layout optimized for mobile and desktop play. Supports drag-and-swap mechanics with match detection and cascading logic.",
        "Timer & Move Limit System: Each level includes a countdown timer and a fixed number of moves, encouraging strategic play and replayability.",
        "Polished UI Design: Clean, animated interface showing score, remaining moves, timer, and match feedback. Includes sound cues and visual pop for combos.",
        "Juicy Feedback & Effects: Particle bursts, screen shakes, and combo animations enhance the tactile feel of every match."],
        "video": "https://drive.google.com/file/d/1AoEH7cRlEhQqWEunkE1GXYXihFOMC3kd/preview",
        "thumbnail": "images/fruity_match.png",
        "tech": ["Unity", "Idle Simulation", "Resource Management", "2D"],
        "repo": "https://github.com/mechanicxengineer/Fruity-Match",
        "live": ""  
      }
    ],
    "tech-demos": [
      {
        "id": "tech-demo-1",
        "title": "TLD: Smart AI - 2D AI Navigation",
        "description": ["This is an advanced AI learning demo built in Unity, designed to showcase real-time obstacle avoidance and intelligent pathfinding in a 2D sprite-based environment. This project demonstrates how AI agents can dynamically navigate complex spaces using collision detection and adaptive movement logic-ideal for top-down games, stealth mechanics, or simulation systems.",
        "Core AI Systems:",
        "2D Sprite-Based Visuals: Characters and obstacles are rendered using crisp 2D sprites, with smooth animations and layered visual feedback.",
        "AI Navigation & Obstacle Avoidance: AI agents use raycasting and physics-based detection to identify nearby obstacles and dynamically adjust their path in real time. Includes steering behaviors and fallback logic for tight spaces.",
        "Collision Detection System: Built on Unity’s 2D physics engine, the system detects and responds to walls, dynamic objects, and other agents. Ensures smooth navigation without overlaps or jitter.",
        "Adaptive Movement Logic: AI agents adjust speed, direction, and decision-making based on environmental context. Includes obstacle prediction and re-routing behaviors.",
        "Modular AI Architecture: Designed with scalability in mind-easily extendable to support patrols, target chasing, or group formations."],
        "video": "https://drive.google.com/file/d/1EDkjg5lQkpeEwpnlIO5onpr1hmbl3WUX/preview",
        "thumbnail": "images/smart_ai_2d.png",
        "tech": ["Unity Engine", "C#", "AI Simulation", "2D Technical"],
        "repo": ""
      },
      {
        "id": "tech-demo-2",
        "title": "TLD: Smart AI - Attack and Straf",
        "description": ["This is an advanced AI behavior demo built in Unreal Engine, focused on reactive combat logic and modular decision-making. It showcases how AI agents can transition between patrol, attack, and evasive maneuvers using Unreal’s native AI framework-ideal for stealth-action, shooter, or RPG prototypes.",
        "Core AI Systems:",
        "AI Controller Framework: Each enemy is governed by a custom AI Controller that interfaces with Behavior Trees and Blackboard data for dynamic state transitions.",
        "Blackboard & Behavior Tree Architecture: Centralized logic using Blackboard keys to track player visibility, attack cooldowns, and movement states. Behavior Trees orchestrate transitions between patrol, engage, attack, and strafe.",
        "BTT_Tasks (Behavior Tree Tasks): Custom task nodes for movement, attack execution, cooldown handling, and strafe direction. Modular design allows easy reuse and expansion.",
        "BTD_Decorators (Behavior Tree Decorators): Conditional checks for player proximity, line-of-sight, attack readiness, and strafe eligibility. Used to gate transitions and prevent logic conflicts.",
        "Combat & Strafing Behavior: AI agents detect the player, initiate attacks, and immediately strafe left or right post-attack to simulate evasive combat. Includes cooldown logic, animation triggers, and pathfinding adjustments."],
        "video": "https://drive.google.com/file/d/1k0ZB8X-XyPQEBDD6As3WVGqgf7V3_TQ1/preview",
        "thumbnail": "images/smart_ai_attack_and_straf.png",
        "tech": ["Unreal Engine", "Blueprints", "C++", "AI Simulation", "Blackboard", "Behavior Tree"],
        "repo": ""
      },
      {
        "id": "tech-demo-3",
        "title": "TLD: Smart AI - Patrol and Chase",
        "description": ["This Logic is an advanced AI behavior demo built in Unreal Engine, designed to showcase dynamic decision-making, modular patrol logic, and reactive enemy intelligence. The project leverages Unreal’s AI framework-including AI Controllers, Behavior Trees, and Blackboard systems-to simulate lifelike enemy behavior in a stealth-action environment.",
        "Core AI Systems:",
        "AI Controller Architecture: Each enemy is governed by a custom AI Controller that interfaces with Behavior Trees and Blackboard data for modular decision-making.",
        "Blackboard & Behavior Tree Integration: Centralized data-driven logic using Blackboard keys to track player visibility, patrol states, and chase triggers. Behavior Trees orchestrate transitions between idle, patrol, alert, and chase states.",
        "BTT_Tasks (Behavior Tree Tasks): Custom task nodes handle movement, waiting, animation triggers, and chase logic. Includes modular task design for easy reuse and expansion.",
        "BTD_Decorators (Behavior Tree Decorators): Conditional checks for visibility, distance, and state transitions. Used to gate behaviors like chasing, returning to patrol, or triggering alerts.",
        "Patrol & Chase System: AI agents follow predefined patrol paths. Upon detecting the player (via line-of-sight or perception), they dynamically switch to chase mode with pathfinding and obstacle avoidance."],
        "video": "https://drive.google.com/file/d/1DNgO1S5quF_TGpokGyMRGS9ETIIRbNkO/preview",
        "thumbnail": "images/smart_ai_patrol_and_chase.png",
        "tech": ["Unreal Engine", "Blueprints", "C++", "AI Simulation", "Blackboard", "Behavior Tree", "Combat"],
        "repo": ""
      },
      {
        "id": "tech-demo-4",
        "title": "TLD: Smart AI - Parry - Block",
        "description": ["This is an advanced AI behavior demo built in Unreal Engine, designed to showcase intelligent enemy defense mechanics in real-time combat scenarios. Using Unreal’s AI Controller, Blackboard, and Behavior Tree systems, this project demonstrates how AI agents can dynamically parry melee attacks and block incoming projectiles-creating lifelike, reactive combat encounters.",
        "Core AI Systems:",
        "AI Controller Framework: Custom AI Controllers manage perception, decision-making, and animation triggers. Each agent responds to player actions with layered defensive logic.",
        "Blackboard & Behavior Tree Architecture: Centralized data-driven logic using Blackboard keys to track player proximity, attack states, projectile detection, and defensive cooldowns. Behavior Trees orchestrate transitions between idle, engage, parry, and block states.",
        "BTT_Tasks (Behavior Tree Tasks): Includes modular tasks for parrying melee attacks, blocking projectiles, cooldown resets, and animation syncing. Designed for reuse across multiple enemy types.",
        "BTD_Decorators (Behavior Tree Decorators): Conditional checks for timing windows, attack direction, projectile velocity, and stamina thresholds. Used to gate defensive actions and prevent logic conflicts.",
        "Parry & Block Mechanics: AI agents detect incoming attacks and respond with timed parries or directional blocks. Includes animation blending, hit reaction suppression, and counter-attack triggers."],
        "video": "https://drive.google.com/file/d/1qyDRXI_LDC-HDqIlZtxSBMO5JQPPqArK/preview",
        "thumbnail": "images/smart_ai_parry_and_block.png",
        "tech": ["Unreal Engine", "Blueprints", "C++", "AI Simulation", "Blackboard", "Behavior Tree", "Combat"],
        "repo": ""
      },
      {
        "id": "tech-demo-5",
        "title": "TLD: Smart AI - Ai vs Ai",
        "description": ["This is an advanced AI learning demo built in Unreal Engine, showcasing autonomous combat between two distinct AI archetypes: a melee fighter and a ranged gunner. Using Unreal’s AI Controller, Blackboard, and Behavior Tree systems, the project demonstrates modular decision-making, reactive combat behavior, and dynamic state transitions-ideal for prototyping enemy factions, PvE scenarios, or training simulations.",
        "Core AI Systems:",
        "AI Controller Framework: Each AI agent is governed by a custom AI Controller that manages perception, movement, and combat logic. Controllers interface with Behavior Trees and Blackboard data for real-time decision-making.",
        "Blackboard & Behavior Tree Architecture: Centralized logic using Blackboard keys to track enemy location, attack readiness, health status, and tactical positioning. Behavior Trees orchestrate transitions between patrol, engage, attack, and evade states.",
        "BTT_Tasks (Behavior Tree Tasks): Includes custom tasks for melee attacks, ranged shooting, cooldown handling, movement, and animation syncing. Each AI type uses specialized tasks tailored to its combat style.",
        "BTD_Decorators (Behavior Tree Decorators): Conditional checks for line-of-sight, distance thresholds, attack cooldowns, and health levels. Used to gate combat actions and trigger evasive maneuvers.",
        "Melee AI: Closes distance, initiates attacks with timed animations, and reacts to ranged damage with chase or retreat logic.",
        "Ranged AI: Maintains distance, fires projectiles using line-of-sight checks, and strafes to avoid melee threats. Includes reload and ammo tracking systems.",
        "Dynamic Combat Loop: Both AI agents engage autonomously, adapting to each other's behavior. Includes hit detection, damage feedback, and reactive movement based on combat outcomes."],
        "video": "https://drive.google.com/file/d/1rDCzlRiO_Twb-ghOIhpjXuBzWHWbt3aG/preview",
        "thumbnail": "images/smart_ai_vs_ai.png",
        "tech": ["Unreal Engine", "Blueprints", "C++", "AI Simulation", "Blackboard", "Behavior Tree", "Combat"],
        "repo": ""
      }
    ],
    "personal-projects": {
        "experimental": [
            {
              "id": "personal-experimental-1",
              "title": "Procedural Dragon Motion",
              "description": ["This is a procedural animation and movement built in Unreal Engine, exploring the fusion of modular geometry and organic motion. The project focuses on generating a chain of connected cubes that simulate the elegant, serpentine movement of a flying Chinese dragon-entirely through procedural logic and without skeletal rigs or pre-made assets.",
              "Core Systems & Features",
              "Procedural Cube Generation: The entire structure is built using only cube meshes, spawned and positioned dynamically in a chain formation. Each cube inherits and offsets its position based on the one ahead, creating a flowing, tail-following effect.",
              "Chain Connection System: A modular system links each cube to the next using transform inheritance and offset logic. The chain maintains spacing, orientation, and smooth transitions, allowing for real-time expansion or contraction.",
              "Dragon-Like Flying Movement: The head of the chain follows a sinusoidal or spline-based path, while the rest of the body flows behind it with delay and curvature - mimicking the graceful, wave-like motion of a traditional Chinese dragon in flight.",
              "Fully Procedural Logic: No skeletal meshes or animations are used. All movement, spacing, and orientation are handled through blueprint logic and mathematical functions, making the system lightweight and highly customizable.",
              "Experimental Use Cases: Ideal for exploring procedural animation, AI path-following, or visual effects prototyping. The system can be extended into enemy formations, boss tentacles, or stylized environmental effects."],
              "video": "https://drive.google.com/file/d/1_9PXH4ZE6Li5-g8ciEOT9gzGOsCMcsfS/preview",
              "thumbnail": "images/procedural_dragon.png",
              "tech": ["Unreal Engine", "Blueprints", "C++", "Experimental", "Procedural Animation", "Technical"],
              "repo": ""
            },
            {
              "id": "personal-experimental-2",
              "title": "Inventory System",
              "description": ["This is a lightweight inventory system built in Unreal Engine using C++, designed to explore intuitive item management, interactive UI feedback, and modular gameplay integration. The project focuses on creating a simple yet expressive inventory experience-ideal for RPGs, survival games, or sandbox systems.",
              "Core Systems & Features",
              "Item Pickup & Storage: Players can interact with world items and store them in a grid-based inventory. Implemented in C++ for efficient memory handling and real-time responsiveness.",
              "Hover Descriptions: Each item displays a contextual tooltip when hovered, showing name, type, and a short description. Tooltip logic and UI binding are handled via C++ and UMG.",
              "Drag & Drop Removal: Items can be dragged out of the inventory to discard or drop them back into the world. Includes slot reordering, visual feedback, and blueprint-exposed C++ functions for flexibility.",
              "Modular Inventory UI: Clean, animated interface built with UMG and backed by C++ logic. Supports item icons, stack counts, slot highlighting, and dynamic updates."],
              "extra" : ["Additional Features:",
              "Item stacking and quantity tracking.",
              "Slot locking and restricted item types.",
              "Sound and visual effects for pickup, drop, and hover.",
              "Blueprint-callable C++ functions for easy customization and extension."],
              "video": "https://drive.google.com/file/d/1n68s-KKStQ0TC-ZEnBMxe-jeUIutKRER/preview",
              "thumbnail": "images/inventory_system.png",
              "tech": ["Unreal Engine", "Blueprints", "C++", "Experimental", "Technical"],
              "repo": ""
            },
            {
              "id": "personal-experimental-3",
              "title": "Root Motion",
              "description": ["This is a root motion–driven experimental built in Unreal Engine, designed to explore physically expressive character movement using animation-based locomotion. The project focuses on syncing gameplay mechanics with animation data to create fluid, grounded motion-ideal for cinematic action games.",
              "Core Systems & Features",
              "Root Motion Movement System: All locomotion is driven directly by animation data, ensuring precise foot placement, natural acceleration, and seamless transitions between movement states.",
              "Dynamic Jump System: Jump animations are selected and scaled based on the height of the target surface or obstacle. Includes root motion–based launch and landing for realistic arc and timing.",
              "Crouch System: Smooth transition into crouch using root motion animations. Includes collision adjustments and movement speed scaling for stealth or traversal scenarios.",
              "Dash & Roll Mechanics: Responsive dash and evasive roll actions triggered by player input. Movement is fully handled via root motion, allowing for cinematic momentum and directional control.",
              "Animation Sync & Blend Logic: All movement states are tightly synced with animation curves and blend spaces, ensuring consistent visual feedback and gameplay responsiveness."],
              "video": "https://drive.google.com/file/d/1FhXJpn6Wqv3jboXnCOff2hVXE3WU1YM_/preview",
              "thumbnail": "images/root_motion.png",
              "tech": ["Unreal Engine", "Blueprints", "Experimental", "Physics", "Movement", "Technical"],
              "repo": ""
            },
            {
              "id": "personal-experimental-4",
              "title": "Day-Night Cycle",
              "description": ["This is a high-fidelity 3D environment built in Unity using the High Definition Render Pipeline (HDRP), focused on simulating a realistic day-night cycle with dynamic celestial movement. The project captures real-time transitions of lighting, atmosphere, and shadows-ideal for open-world games, architectural visualization, or cinematic environments.",
              "Core Systems & Features",
              "Real-Time Sun & Moon Placement: The sun and moon are procedurally positioned based on time-of-day logic, with accurate elevation, rotation, and light intensity synced to a virtual clock.",
              "HDRP Lighting & Atmosphere: Uses HDRP’s advanced lighting features including volumetric fog, physically based sky, and dynamic exposure to simulate natural transitions from dawn to dusk and nightfall.",
              "Time-Driven Cycle System: A scalable time manager drives the rotation of celestial bodies, ambient light shifts, and skybox transitions. Supports accelerated or real-time playback.",
              "Shadow & Reflection Updates: Dynamic shadows and screen-space reflections adjust seamlessly with the sun/moon position, enhancing realism across terrain, foliage, and architecture.",
              "Captured in Real-Time Engine: All visuals and lighting transitions are rendered live in Unity’s engine-no baked lighting or pre-rendered sequences. Ideal for showcasing HDRP’s power in interactive environments."],
              "video": "https://drive.google.com/file/d/1KsHWARdEbjre7tuSIiEuraITmxO9QBZ1/preview",
              "thumbnail": "images/day_night_cycle.png",
              "tech": ["Unity (HDRP)", "Environmental Simulation", "Experimental", "Physics", "3D Lighting", "Technical"],
              "repo": ""
            }
        ],
        "failure": [
            {
              "id": "personal-failure-1",
              "title": "Soul Style - Combo and LockOn Target",
              "description": ["This is a Souls-like experimental demo built in Unreal Engine, designed to explore expressive character movement, reactive combat systems, and intelligent enemy behavior. Though the project faced technical and design challenges, it served as a valuable learning experience in building modular gameplay systems and understanding the complexity of animation-driven combat.",
              "Core Systems & Features",
              "Character Movement System: Includes walk, run, roll, and strafe with root motion–based transitions for grounded responsiveness and cinematic flow.",
              "Combat Animation & Combo System, Controller-based input logic featuring: ✦ Chorded Keys for combo branching, ✦ Held Keys for charge attacks, ✦ Input Buffers for queuing special moves Designed to simulate timing-based, expressive melee combat.",
              "Aim Lock-On System: Dynamic lock-on targeting with camera alignment, enemy switching, and disengage logic based on distance and visibility.",
              "AI Enemies with Combat Abilities: Behavior Tree–driven enemies capable of attacking and reacting to player actions. Includes animation syncing, hit detection, and stagger logic.",
              "Health & Damage System: Modular health architecture with damage types, invincibility frames, and death triggers for both player and AI entities.",
              "Interaction System: Contextual prompts for pickups, doors, NPCs, and environmental triggers with animation and UI feedback."],
              "extra": ["What I Learned from This Project",
              "Root Motion Requires Rigorous Syncing: Implementing walk, run, roll, and strafe with root motion taught me how critical it is to align animation curves, blend spaces, and movement logic. Even small mismatches caused gameplay feel to break.",
              "Combat Input Systems Are Deeply Layered: Building a controller-based combo system with chorded keys, held inputs, and input buffering revealed how timing, state machines, and animation events must work in harmony. It pushed me to think modularly and anticipate edge cases.",
              "Lock-On Systems Affect Everything: Adding aim lock-on reshaped how I approached camera control, movement direction, and targeting logic. I learned how even a small system like this ripples across the entire combat experience.",
              "AI Combat Isn’t Just About Attacking: Designing enemies that could attack, react, and feel fair required a deeper understanding of Behavior Trees, animation syncing, and combat pacing. I learned how to balance aggression with readability.",
              "Interaction Systems Need Flexibility: Even simple interactions-like picking up items or opening doors-needed clean architecture to avoid bugs and ensure scalability. I learned to separate visual prompts, input handling, and world logic.",
              "Failure Is a Design Compass: The project didn’t fully meet my vision, but every broken combo, misaligned animation, or AI glitch taught me how to build smarter, cleaner systems next time. It sharpened my instincts for what makes Souls-like combat feel satisfying."],
              "video": "https://drive.google.com/file/d/13rgSVb2JdGl6rNz6sSEEhCqHEPWWecAT/preview",
              "thumbnail": "images/soulstyle_combo.png",
              "tech": ["Unreal Engine", "Blueprints", "C++", "Action RPG", "Combat Prototype", "Experimental"]
            },
            {
              "id": "personal-failure-2",
              "title": "Soul Style - Combat system and Enemies",
              "description": ["This is a combat-focused prototype built in Unreal Engine, Part of above project of Souls-like games. Though the project faced limitations and remains incomplete, it served as a hands-on exploration of real-time combat systems, animation-driven movement, and AI behavior. The core loop centers around the player actively fighting AI enemies in a reactive, timing-based environment.",
              "Core Systems & Features",
              "Character Movement System Includes walk, run, roll, and strafe mechanics with smooth transitions and directional responsiveness. Movement is tightly synced with animation states to preserve weight and pacing.",
              "Controller-Based Combo System Combat is driven by a modular input system supporting: ✦ Light and heavy attacks, ✦ Chained combos based on input timing, ✦ Directional attacks and stamina-based restrictions Built to support controller input with layered animation montages and combo branching.",
              "Aim Lock-On System Players can lock onto enemies for focused combat. The system dynamically adjusts camera orientation, movement direction, and target switching during fights.",
              "AI Enemies with Combat Behavior Enemies actively engage the player with attack animations, movement logic, and reaction states. They can chase, strike, and reposition during combat, creating a dynamic battlefield.",
              "Health & Damage System Both player and enemies have modular health components, damage types, and hit reactions. Includes invincibility frames, stagger logic, and death triggers.",
              "Real-Time Combat Loop The player and enemies fight in live, unscripted encounters. Timing, positioning, and animation syncing are critical. The system supports multiple enemies, combo interruptions, and reactive AI behavior."],
              "extra": ["What I Learned",
              "Building real-time combat requires precise animation syncing and input buffering.",
              "AI behavior must be modular and reactive to feel fair and engaging.",
              "Lock-on systems affect movement, targeting, and camera flow more than expected.",
              "Even failed systems reveal how to design better, cleaner, and more scalable mechanics."],
              "video": "https://drive.google.com/file/d/1efd_H2c4HRaxNd5TUyUSJHiPFu7-oeF4/preview",
              "thumbnail": "images/soulstyle_fighting.png",
              "tech": ["Unreal Engine", "Blueprints", "C++", "Action RPG", "Combat Prototype", "Experimental"]
            },
            {
              "id": "personal-failure-3",
              "title": "AI Traffic Simulation",
              "description": ["This is a hybrid-perspective car driving demo built in Unity using the Universal Render Pipeline (URP). The project features both third-person and top-down camera modes, allowing players to switch perspectives while navigating a dynamic urban environment. At its core is an advanced AI traffic system that simulates real-world driving behavior, complete with responsive AI vehicles, traffic flow logic, and intersection handling.",
              "Core Systems & Features",
              "Dual Camera Modes: Seamlessly switch between third-person and top-down views for different gameplay styles-ideal for arcade driving, tactical navigation, or simulation testing.",
              "Advanced AI Traffic System: AI-controlled vehicles follow realistic traffic rules, including: ✦ Lane-based navigation and pathfinding, ✦ Obstacle detection and avoidance, ✦ Traffic light and stop sign compliance, ✦ Yielding, overtaking, and intersection logic Designed to mimic real-life traffic behavior in a modular and scalable way.",
              "AI Car Behavior: Each AI vehicle uses waypoint systems, raycasting, and state machines to react to the environment, other cars, and the player. Includes acceleration, braking, turning, and collision avoidance.",
              "URP Visuals & Optimization: Clean, stylized visuals rendered through Unity’s URP for optimized performance and lighting. Supports dynamic shadows, post-processing, and scalable quality settings.",
              "Player Driving System: Responsive car controller with acceleration, braking, steering, and camera-relative movement. Designed for both casual and simulation-style driving."],
              "extra": ["What I Learned from AI Traffic Simulation",
              "Realistic Traffic Behavior Is a System of Systems: I discovered that simulating lifelike traffic isn’t just about moving cars-it requires layered systems for lane logic, intersection handling, obstacle detection, and timing coordination.",
              "Waypoint and State Machines Are Essential: Building AI cars taught me how to use waypoints and state machines to manage transitions between driving, stopping, yielding, and turning. This helped me modularize behavior and avoid spaghetti logic.",
              "Collision Avoidance Needs Prediction, Not Just Reaction: I learned that reactive avoidance leads to jittery movement. Predictive logic-like raycasting ahead and checking velocity-creates smoother, more believable traffic flow.",
              "Traffic Lights and Intersections Are Complex but Rewarding: Implementing traffic signals and multi-lane intersections showed me how timing, priority rules, and vehicle communication can make or break immersion.",
              "Top-Down and Third-Person Views Require Different Design Thinking: Supporting both perspectives taught me how camera framing affects player perception, navigation clarity, and UI placement.",
              "Debugging AI in Motion Is a Skill in Itself: I gained experience using gizmos, visual debuggers, and runtime logs to track AI decisions and fix unexpected behavior in real time."],
              "video": "https://drive.google.com/file/d/1VtESJ-xCWE_v6vm09sp97nQdo4PxKmwK/preview",
              "thumbnail": "images/traffic_system.png",
              "tech": ["Unity (URP)", "Driving Simulator", "AI Systems", "Traffic System", "Technical"]
            }
        ]
    }
  },
  "contact": {
    "email": "id.manishkumarsingh@gmail.com",
    "phone": "+91 915350-5989",
    "location": "Hyderabad, India",
    "social": {
      "github": "https://github.com/mechanicxengineer",
      "linkedin": "https://www.linkedin.com/in/mechanicxengineer/",
      "instagram": "https://www.instagram.com/theaagstya/"
    }
  }
}